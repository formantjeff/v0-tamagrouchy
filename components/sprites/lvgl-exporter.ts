/**
 * Generates a C source file content compatible with LVGL for the given frames.
 * Supports 1-bit (Indexed) and Color (RGB565).
 */
export function generateLVGLHeader(
  frames: (number | string)[][][],
  width: number,
  height: number,
  mode: "1-bit" | "color",
  fps: number,
  varName = "sprite_anim", // Added varName parameter with default
): string {
  const frameDuration = Math.round(1000 / fps)

  let cCode = `/**\n`
  cCode += ` * Generated by v0 Sprite Tool\n`
  cCode += ` * Resolution: ${width}x${height}\n`
  cCode += ` * Mode: ${mode}\n`
  cCode += ` * FPS: ${fps}\n`
  cCode += ` */\n\n`

  cCode += `#include "lvgl.h"\n\n`

  // Generate data for each frame
  frames.forEach((frame, index) => {
    cCode += `// Frame ${index}\n`
    cCode += `const uint8_t ${varName}_${index}_map[] = {\n`

    if (mode === "1-bit") {
      // LV_IMG_CF_INDEXED_1BIT
      // Palette: 2 colors * 4 bytes (B, G, R, A)
      // Color 0: Black (0,0,0,255)
      cCode += `  0x00, 0x00, 0x00, 0xff, // Color 0: Black\n`
      // Color 1: White (255,255,255,255)
      cCode += `  0xff, 0xff, 0xff, 0xff, // Color 1: White\n`
      cCode += `  \n  // Bitmap Data\n  `

      // Pack bits
      const rows = frame as number[][]
      let byte = 0
      let bitCount = 0
      let bytesLine = []

      for (let y = 0; y < height; y++) {
        for (let x = 0; x < width; x++) {
          // 1-bit: 0 = Black (Color 0), 1 = White (Color 1)
          // In our data: 0 = Black, 1 = White.
          // LVGL Indexed: Index 0 or 1.
          // We map our 0->0, 1->1.
          const pixel = rows[y][x]

          // MSB first
          if (pixel === 1) {
            byte |= 1 << (7 - bitCount)
          }

          bitCount++

          if (bitCount === 8) {
            bytesLine.push(`0x${byte.toString(16).padStart(2, "0")}`)
            byte = 0
            bitCount = 0
          }
        }
        // If width is not multiple of 8, pad the rest of the byte?
        // LVGL usually expects scanlines to be byte-aligned?
        // Actually LVGL Indexed 1bit packs tightly, but let's assume byte alignment for safety or check spec.
        // Spec: "The rows are padded to byte (8 bit) boundary."
        if (bitCount > 0) {
          bytesLine.push(`0x${byte.toString(16).padStart(2, "0")}`)
          byte = 0
          bitCount = 0
        }

        cCode += bytesLine.join(", ") + ",\n  "
        bytesLine = []
      }
    } else {
      // LV_IMG_CF_TRUE_COLOR (RGB565)
      // 2 bytes per pixel
      cCode += `  `
      const rows = frame as string[][]
      let bytesLine = []

      for (let y = 0; y < height; y++) {
        for (let x = 0; x < width; x++) {
          const hex = rows[y][x]
          // Parse hex #RRGGBB
          const r = Number.parseInt(hex.slice(1, 3), 16)
          const g = Number.parseInt(hex.slice(3, 5), 16)
          const b = Number.parseInt(hex.slice(5, 7), 16)

          // Convert to RGB565
          // R: 5 bits, G: 6 bits, B: 5 bits
          const r5 = (r >> 3) & 0x1f
          const g6 = (g >> 2) & 0x3f
          const b5 = (b >> 3) & 0x1f

          const rgb565 = (r5 << 11) | (g6 << 5) | b5

          // Little Endian for ESP32: Low byte, High byte
          const lowByte = rgb565 & 0xff
          const highByte = (rgb565 >> 8) & 0xff

          bytesLine.push(`0x${lowByte.toString(16).padStart(2, "0")}, 0x${highByte.toString(16).padStart(2, "0")}`)
        }
        cCode += bytesLine.join(", ") + ",\n  "
        bytesLine = []
      }
    }

    cCode += `};\n\n`

    // Generate Descriptor
    cCode += `const lv_img_dsc_t ${varName}_${index} = {\n`
    cCode += `  .header.always_zero = 0,\n`
    cCode += `  .header.w = ${width},\n`
    cCode += `  .header.h = ${height},\n`

    // Calculate data size
    let dataSize = 0
    if (mode === "1-bit") {
      // Palette (8) + Bitmap
      // Bitmap: ceil(width/8) * height
      dataSize = 8 + Math.ceil(width / 8) * height
      cCode += `  .data_size = ${dataSize},\n`
      cCode += `  .header.cf = LV_IMG_CF_INDEXED_1BIT,\n`
    } else {
      // RGB565: w * h * 2
      dataSize = width * height * 2
      cCode += `  .data_size = ${dataSize},\n`
      cCode += `  .header.cf = LV_IMG_CF_TRUE_COLOR,\n`
    }

    cCode += `  .data = ${varName}_${index}_map,\n`
    cCode += `};\n\n`
  })

  // Generate Animation Array
  cCode += `// Animation Frames Array\n`
  cCode += `const lv_img_dsc_t* ${varName}_imgs[] = {\n`
  frames.forEach((_, index) => {
    cCode += `  &${varName}_${index},\n`
  })
  cCode += `};\n\n`

  cCode += `// Animation Configuration\n`
  cCode += `const int ${varName}_count = ${frames.length};\n`
  cCode += `const int ${varName}_duration = ${frameDuration};\n`

  return cCode
}
